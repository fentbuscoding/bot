from discord.ext import commands
from cogs.logging.logger import CogLogger
from utils.db import db
from utils.safe_reply import safe_reply
from utils.tos_handler import check_tos_acceptance, prompt_tos_acceptance
import discord
import random
import asyncio
import time
import json
import discord
import random
import asyncio
import time
import json
import os

class Work(commands.Cog):
    def __init__(self, bot):
        self.bot = bot
        self.logger = CogLogger(self.__class__.__name__)
        self.currency = "<:bronkbuk:1377389238290747582>"
        self.pending_raises = {}  # Track raise requests for group bonuses
        self.work_cooldowns = {}  # Track work cooldowns per user
        
        # Load job definitions
        self.jobs = {
            "discord_mod": {
                "name": "Discord Moderator",
                "wage": {"min": 200, "max": 800},
                "boss": {"hostile": 5, "loyalty": 0},
                "emoji": "ðŸ”¨",
                "description": "Delete messages and ban users for the greater good",
                "minigame": "moderation"
            },
            "reddit_admin": {
                "name": "Reddit Admin", 
                "wage": {"min": 500, "max": 1500},
                "boss": {"hostile": 10, "loyalty": 0},
                "emoji": "ðŸ¤“",
                "description": "Control the narrative and moderate subreddits",
                "minigame": "reddit"
            },
            "pokimane_sub": {
                "name": "Pokimane Subscriber",
                "wage": {"min": 50, "max": 300},
                "boss": {"hostile": 0, "loyalty": 10},
                "emoji": "ðŸ’¸",
                "description": "Donate your life savings for a chance at a shoutout",
                "minigame": "simp"
            },
            "meme_poster": {
                "name": "Professional Meme Poster",
                "wage": {"min": 100, "max": 600},
                "boss": {"hostile": 3, "loyalty": 5},
                "emoji": "ðŸ—¿",
                "description": "Create dank memes for internet points",
                "minigame": "meme"
            },
            "nft_trader": {
                "name": "NFT Trader",
                "wage": {"min": 0, "max": 5000},
                "boss": {"hostile": 20, "loyalty": 0},
                "emoji": "ðŸ–¼ï¸",
                "description": "Right-click save forbidden JPEGs",
                "minigame": "nft"
            },
            "crypto_investor": {
                "name": "Crypto Day Trader",
                "wage": {"min": 50, "max": 3000},
                "boss": {"hostile": 15, "loyalty": 0},
                "emoji": "ðŸ“ˆ",
                "description": "Lose money with diamond hands",
                "minigame": "crypto"
            },
            "twitter_warrior": {
                "name": "Twitter Social Justice Warrior",
                "wage": {"min": 0, "max": 400},
                "boss": {"hostile": 25, "loyalty": 0},
                "emoji": "ðŸ¦",
                "description": "Get offended professionally",
                "minigame": "twitter"
            },
            "twitch_streamer": {
                "name": "Twitch Streamer",
                "wage": {"min": 20, "max": 2000},
                "boss": {"hostile": 5, "loyalty": 15},
                "emoji": "ðŸŽ®",
                "description": "Entertain 3 viewers including your mom",
                "minigame": "streaming"
            }
        }

    async def cog_check(self, ctx):
        """Global check for all commands in this cog"""
        # Check if user has accepted ToS
        if not await check_tos_acceptance(ctx.author.id):
            await prompt_tos_acceptance(ctx)
            return False
        return True

    async def get_user_job(self, user_id: int):
        """Retrieve user's job data from the database."""
        user_data = await db.db.users.find_one({"_id": str(user_id)})
        return user_data.get("work", None)

    async def update_user_job(self, user_id, job_data):
        """Update user's job data in the database."""
        await db.db.users.update_one({"_id": str(user_id)}, {"$set": {"work": job_data}}, upsert=True)

    async def can_work(self, user_id: int) -> tuple[bool, int]:
        """Check if user can work and return cooldown remaining"""
        last_work = self.work_cooldowns.get(user_id, 0)
        current_time = time.time()
        cooldown_remaining = max(0, 60 - (current_time - last_work))
        return cooldown_remaining == 0, int(cooldown_remaining)

    async def set_work_cooldown(self, user_id: int):
        """Set work cooldown for user"""
        self.work_cooldowns[user_id] = time.time()

    @discord.app_commands.command(name="job", description="Manage your job and career")
    async def job_slash(self, interaction: discord.Interaction):
        """Main job command with interactive menu"""
        user_job = await self.get_user_job(interaction.user.id)
        
        if user_job and user_job.get("cooldown", 0) > time.time():
            remaining = int(user_job["cooldown"] - time.time())
            hours = remaining // 3600
            minutes = (remaining % 3600) // 60
            embed = discord.Embed(
                title="â„ï¸ Job Cooldown",
                description=f"You recently left a job. You can choose a new one in **{hours}h {minutes}m**",
                color=0x3498db
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return
        
        embed = discord.Embed(
            title="ðŸ’¼ Job Management",
            description="Choose what you'd like to do:",
            color=0x2ecc71
        )
        
        if user_job and "name" in user_job:
            embed.add_field(
                name=f"{self.jobs.get(user_job.get('job_id', ''), {}).get('emoji', 'ðŸ’¼')} Current Job",
                value=f"**{user_job['name']}**\nWage: {user_job['wage']['min']:,} - {user_job['wage']['max']:,} {self.currency}\nHostility: {user_job['boss']['hostile']}/100\nLoyalty: {user_job['boss']['loyalty']}/100",
                inline=False
            )
        else:
            embed.add_field(
                name="ðŸ“‹ Employment Status",
                value="**Unemployed**\nChoose a job to start earning!",
                inline=False
            )
        
        view = JobManagementView(self, user_job, interaction.user.id)
        await interaction.response.send_message(embed=embed, view=view)

    @discord.app_commands.command(name="work", description="Work at your job to earn money")
    async def work_slash(self, interaction: discord.Interaction):
        """Work command with minigame"""
        # Check work cooldown first
        can_work, cooldown_remaining = await self.can_work(interaction.user.id)
        if not can_work:
            embed = discord.Embed(
                title="â° Work Cooldown",
                description=f"You need to wait **{cooldown_remaining}** seconds before working again.",
                color=0xf39c12
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        user_job = await self.get_user_job(interaction.user.id)
        if not user_job or "name" not in user_job:
            embed = discord.Embed(
                title="ðŸš« No Job",
                description="You need a job first! Use `/job` to choose one.",
                color=0xe74c3c
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        job_id = user_job.get("job_id", "")
        job_info = self.jobs.get(job_id, {})
        minigame_type = job_info.get("minigame", "default")
        
        # Start the appropriate minigame
        if minigame_type == "moderation":
            view = ModerationMinigame(self, user_job, interaction.user.id)
        elif minigame_type == "reddit":
            view = RedditMinigame(self, user_job, interaction.user.id)
        elif minigame_type == "simp":
            view = SimpMinigame(self, user_job, interaction.user.id)
        elif minigame_type == "meme":
            view = MemeMinigame(self, user_job, interaction.user.id)
        elif minigame_type == "nft":
            view = NFTMinigame(self, user_job, interaction.user.id)
        elif minigame_type == "crypto":
            view = CryptoMinigame(self, user_job, interaction.user.id)
        elif minigame_type == "twitter":
            view = TwitterMinigame(self, user_job, interaction.user.id)
        elif minigame_type == "streaming":
            view = StreamingMinigame(self, user_job, interaction.user.id)
        else:
            view = DefaultMinigame(self, user_job, interaction.user.id)
        
        if minigame_type == "default" or minigame_type not in ["moderation", "reddit", "simp", "meme", "nft", "crypto", "twitter", "streaming"]:
            embed = discord.Embed(
                title="ðŸ’£ Minesweeper - Clear the field!",
                description=f"```\n{view.get_board_display()}\n```\nClick cells to reveal them. Use flag mode to mark mines!",
                color=0x3498db
            )
        else:
            embed = discord.Embed(
                title=f"{job_info.get('emoji', 'ðŸ’¼')} {user_job['name']}",
                description=f"Time to get to work! {job_info.get('description', '')}",
                color=0x3498db
            )
        
        await interaction.response.send_message(embed=embed, view=view)

    # Traditional text commands
    @commands.command(name="job", aliases=["career"])
    async def job_text(self, ctx):
        """Traditional job management command"""
        user_job = await self.get_user_job(ctx.author.id)
        
        if user_job and user_job.get("cooldown", 0) > time.time():
            remaining = int(user_job["cooldown"] - time.time())
            hours = remaining // 3600
            minutes = (remaining % 3600) // 60
            embed = discord.Embed(
                title="â„ï¸ Job Cooldown",
                description=f"You recently left a job. You can choose a new one in **{hours}h {minutes}m**",
                color=0x3498db
            )
            await ctx.reply(embed=embed)
            return
        
        embed = discord.Embed(
            title="ðŸ’¼ Job Management",
            description="Choose what you'd like to do:",
            color=0x2ecc71
        )
        
        if user_job and "name" in user_job:
            embed.add_field(
                name=f"{self.jobs.get(user_job.get('job_id', ''), {}).get('emoji', 'ðŸ’¼')} Current Job",
                value=f"**{user_job['name']}**\nWage: {user_job['wage']['min']:,} - {user_job['wage']['max']:,} {self.currency}\nHostility: {user_job['boss']['hostile']}/100\nLoyalty: {user_job['boss']['loyalty']}/100",
                inline=False
            )
        else:
            embed.add_field(
                name="ðŸ“‹ Employment Status",
                value="**Unemployed**\nChoose a job to start earning!",
                inline=False
            )
        
        view = JobManagementView(self, user_job, ctx.author.id)
        await ctx.reply(embed=embed, view=view)

    @commands.command(name="work", aliases=["wrk", "earn"])
    @commands.cooldown(1, 60, commands.BucketType.user)
    async def work_text(self, ctx):
        """Traditional work command with minigame"""
        # Check work cooldown first
        can_work, cooldown_remaining = await self.can_work(ctx.author.id)
        if not can_work:
            embed = discord.Embed(
                title="â° Work Cooldown",
                description=f"You need to wait **{cooldown_remaining}** seconds before working again.",
                color=0xf39c12
            )
            await ctx.reply(embed=embed)
            return

        user_job = await self.get_user_job(ctx.author.id)
        if not user_job or "name" not in user_job:
            embed = discord.Embed(
                title="ðŸš« No Job",
                description="You need a job first! Use `.job` or `/job` to choose one.",
                color=0xe74c3c
            )
            await ctx.reply(embed=embed)
            return

        job_id = user_job.get("job_id", "")
        job_info = self.jobs.get(job_id, {})
        minigame_type = job_info.get("minigame", "default")
        
        # Start the appropriate minigame
        if minigame_type == "moderation":
            view = ModerationMinigame(self, user_job, ctx.author.id)
        elif minigame_type == "reddit":
            view = RedditMinigame(self, user_job, ctx.author.id)
        elif minigame_type == "simp":
            view = SimpMinigame(self, user_job, ctx.author.id)
        elif minigame_type == "meme":
            view = MemeMinigame(self, user_job, ctx.author.id)
        elif minigame_type == "nft":
            view = NFTMinigame(self, user_job, ctx.author.id)
        elif minigame_type == "crypto":
            view = CryptoMinigame(self, user_job, ctx.author.id)
        elif minigame_type == "twitter":
            view = TwitterMinigame(self, user_job, ctx.author.id)
        elif minigame_type == "streaming":
            view = StreamingMinigame(self, user_job, ctx.author.id)
        else:
            view = DefaultMinigame(self, user_job, ctx.author.id)
        
        if minigame_type == "default" or minigame_type not in ["moderation", "reddit", "simp", "meme", "nft", "crypto", "twitter", "streaming"]:
            embed = discord.Embed(
                title="ðŸ’£ Minesweeper - Clear the field!",
                description=f"```\n{view.get_board_display()}\n```\nClick cells to reveal them. Use flag mode to mark mines!",
                color=0x3498db
            )
        else:
            embed = discord.Embed(
                title=f"{job_info.get('emoji', 'ðŸ’¼')} {user_job['name']}",
                description=f"Time to get to work! {job_info.get('description', '')}",
                color=0x3498db
            )
        
        await ctx.reply(embed=embed, view=view)

    @commands.command(name="choosejob", aliases=["selectjob", "getjob"])
    async def choose_job_text(self, ctx, *, job_name: str = None):
        """Choose a job by name or open selection menu"""
        user_job = await self.get_user_job(ctx.author.id)
        
        if user_job and "name" in user_job:
            embed = discord.Embed(
                title="âš ï¸ Already Employed",
                description="You already have a job! Use `.leavejob` first if you want to switch.",
                color=0xf39c12
            )
            await ctx.reply(embed=embed)
            return
        
        if job_name:
            # Try to find job by name
            job_id = None
            for jid, job_data in self.jobs.items():
                if job_data["name"].lower() == job_name.lower() or jid == job_name.lower():
                    job_id = jid
                    break
            
            if job_id:
                job_data = self.jobs[job_id].copy()
                job_data["job_id"] = job_id
                job_data["free_raise"] = False
                
                await self.update_user_job(ctx.author.id, job_data)
                
                embed = discord.Embed(
                    title="ðŸŽ‰ Job Acquired!",
                    description=f"You are now a **{job_data['name']}**!\n\n{job_data['description']}\n\nWage Range: {job_data['wage']['min']:,} - {job_data['wage']['max']:,} {self.currency}",
                    color=0x2ecc71
                )
                await ctx.reply(embed=embed)
            else:
                embed = discord.Embed(
                    title="âŒ Job Not Found",
                    description=f"Could not find job: `{job_name}`\nUse `.jobs` to see available jobs.",
                    color=0xe74c3c
                )
                await ctx.reply(embed=embed)
        else:
            # Show job selection menu
            view = JobSelectionView(self, ctx.author.id)
            embed = discord.Embed(
                title="ðŸŽ¯ Choose Your Career Path",
                description="Select a job that matches your skillset:",
                color=0x9b59b6
            )
            await ctx.reply(embed=embed, view=view)

    @commands.command(name="leavejob", aliases=["quitjob", "quit"])
    async def leave_job_text(self, ctx):
        """Leave current job"""
        user_job = await self.get_user_job(ctx.author.id)
        if not user_job or "name" not in user_job:
            await ctx.reply("You don't have a job to leave!")
            return
            
        cooldown = time.time() + 6 * 3600
        await self.update_user_job(ctx.author.id, {"cooldown": cooldown})
        
        embed = discord.Embed(
            title="ðŸšª Job Left",
            description=f"You have left your job as **{user_job['name']}**.\nYou can choose a new job in **6 hours**.",
            color=0xe74c3c
        )
        await ctx.reply(embed=embed)

    @commands.command(name="jobstatus", aliases=["mystatus", "workstatus"])
    async def job_status_text(self, ctx):
        """Check current job status"""
        user_job = await self.get_user_job(ctx.author.id)
        
        if not user_job:
            embed = discord.Embed(
                title="ðŸ“‹ Employment Status",
                description="**Unemployed**\nUse `.choosejob` to find work!",
                color=0x95a5a6
            )
            await ctx.reply(embed=embed)
            return
        
        if user_job.get("cooldown", 0) > time.time():
            remaining = int(user_job["cooldown"] - time.time())
            hours = remaining // 3600
            minutes = (remaining % 3600) // 60
            embed = discord.Embed(
                title="â„ï¸ Job Cooldown",
                description=f"You recently left a job. You can choose a new one in **{hours}h {minutes}m**",
                color=0x3498db
            )
            await ctx.reply(embed=embed)
            return
        
        if "name" not in user_job:
            embed = discord.Embed(
                title="ðŸ“‹ Employment Status",
                description="**Unemployed**\nUse `.choosejob` to find work!",
                color=0x95a5a6
            )
            await ctx.reply(embed=embed)
            return
        
        job_info = self.jobs.get(user_job.get("job_id", ""), {})
        embed = discord.Embed(
            title=f"{job_info.get('emoji', 'ðŸ’¼')} Job Status",
            color=0x2ecc71
        )
        
        embed.add_field(
            name="Current Position",
            value=f"**{user_job['name']}**\n{job_info.get('description', '')}",
            inline=False
        )
        
        embed.add_field(
            name="ðŸ’° Wage Range",
            value=f"{user_job['wage']['min']:,} - {user_job['wage']['max']:,} {self.currency}",
            inline=True
        )
        
        embed.add_field(
            name="ðŸ˜¡ Boss Hostility",
            value=f"{user_job['boss']['hostile']}/100",
            inline=True
        )
        
        embed.add_field(
            name="â¤ï¸ Boss Loyalty",
            value=f"{user_job['boss']['loyalty']}/100",
            inline=True
        )
        
        await ctx.reply(embed=embed)

    @commands.command(name="askraise", aliases=["raise", "promotion"])
    async def ask_raise_text(self, ctx):
        """Ask boss for a raise"""
        user_job = await self.get_user_job(ctx.author.id)
        if not user_job or "name" not in user_job:
            await ctx.reply("You need a job first!")
            return

        if user_job["boss"]["hostile"] > 50:
            embed = discord.Embed(
                title="ðŸ˜¡ Boss Too Hostile",
                description="Your boss is too angry to consider a raise right now. Try gifting them something first!",
                color=0xe74c3c
            )
            await ctx.reply(embed=embed)
            return

        # Check for group raise opportunity
        job_id = user_job.get("job_id", "")
        current_time = time.time()
        
        # Clean old requests
        for key in list(self.pending_raises.keys()):
            if current_time - self.pending_raises[key]["time"] > 2:
                del self.pending_raises[key]
        
        # Check if someone else with same job asked recently
        group_raise = False
        for user_id, data in self.pending_raises.items():
            if data["job_id"] == job_id and user_id != str(ctx.author.id):
                group_raise = True
                break
        
        # Add current request
        self.pending_raises[str(ctx.author.id)] = {
            "job_id": job_id,
            "time": current_time
        }
        
        success_chance = user_job["boss"]["loyalty"] + 20
        if group_raise:
            success_chance = 100  # Guaranteed success for group raises
        
        success = random.randint(0, 100) < success_chance
        
        if success:
            if group_raise and not user_job.get("free_raise", False):
                # Group raise bonus
                raise_amount = random.randint(200, 800)
                user_job["wage"]["max"] += raise_amount
                user_job["free_raise"] = True
                await self.update_user_job(ctx.author.id, user_job)
                
                embed = discord.Embed(
                    title="ðŸŽ‰ GROUP RAISE APPROVED!",
                    description=f"You and your coworkers demanded a raise together!\nYour maximum wage increased by **{raise_amount:,}** {self.currency}!",
                    color=0xf1c40f
                )
            else:
                raise_amount = random.randint(100, 500)
                user_job["wage"]["max"] += raise_amount
                user_job["boss"]["loyalty"] += 5
                await self.update_user_job(ctx.author.id, user_job)
                
                embed = discord.Embed(
                    title="ðŸ’° Raise Approved!",
                    description=f"Your boss approved your raise!\nMaximum wage increased by **{raise_amount:,}** {self.currency}",
                    color=0x2ecc71
                )
        else:
            user_job["boss"]["hostile"] += 5
            await self.update_user_job(ctx.author.id, user_job)
            
            embed = discord.Embed(
                title="âŒ Raise Denied",
                description="Your boss declined your raise request and is now more hostile.",
                color=0xe74c3c
            )
        
        await ctx.reply(embed=embed)

    @commands.command(name="giftboss", aliases=["gift", "bribe"])
    async def gift_boss_text(self, ctx, *, item_name: str = None):
        """Gift items to your boss"""
        user_job = await self.get_user_job(ctx.author.id)
        if not user_job or "name" not in user_job:
            await ctx.reply("You need a job first!")
            return

        if not item_name:
            # Show available items to gift
            try:
                with open('/home/ks/Desktop/bot/data/shop/items.json', 'r') as f:
                    shop_items = json.load(f)
            except:
                shop_items = {}
            
            inventory = await db.get_inventory(ctx.author.id)
            giftable_items = []
            
            # Check inventory for giftable items
            for item in inventory:
                if not isinstance(item, dict):
                    continue
                item_id = item.get("id", item.get("name", "").lower().replace(" ", "_"))
                if item_id in shop_items:
                    giftable_items.append(item)
            
            if not giftable_items:
                embed = discord.Embed(
                    title="ðŸŽ No Gifts Available",
                    description="You don't have any items to gift your boss. Buy something from the shop first!",
                    color=0xf39c12
                )
                await ctx.reply(embed=embed)
                return
            
            # Create selection for gifting
            view = GiftSelectionView(self, user_job, giftable_items)
            embed = discord.Embed(
                title="ðŸŽ Choose a Gift",
                description="Select an item to gift your boss:",
                color=0x9b59b6
            )
            await ctx.reply(embed=embed, view=view)
        else:
            # Try to gift specific item
            success = await db.remove_from_inventory(ctx.author.id, ctx.guild.id, item_name, 1)
            
            if success:
                # Load shop items to get value
                try:
                    with open('/home/ks/Desktop/bot/data/shop/items.json', 'r') as f:
                        shop_items = json.load(f)
                    item_value = shop_items.get(item_name, {}).get("price", 100)
                except:
                    item_value = 100
                
                hostility_reduction = min(30, max(5, item_value // 1000))
                loyalty_increase = min(15, max(2, item_value // 2000))
                
                user_job["boss"]["hostile"] = max(0, user_job["boss"]["hostile"] - hostility_reduction)
                user_job["boss"]["loyalty"] = min(100, user_job["boss"]["loyalty"] + loyalty_increase)
                
                await self.update_user_job(ctx.author.id, user_job)
                
                embed = discord.Embed(
                    title="ðŸŽ Gift Delivered!",
                    description=f"You gifted **{item_name}** to your boss!\n\nHostility: -{hostility_reduction}\nLoyalty: +{loyalty_increase}",
                    color=0x2ecc71
                )
                await ctx.reply(embed=embed)
            else:
                embed = discord.Embed(
                    title="âŒ Gift Failed",
                    description=f"You don't have **{item_name}** in your inventory.",
                    color=0xe74c3c
                )
                await ctx.reply(embed=embed)

    @commands.command(name="joblist", aliases=["jobs", "careers", "jobslist"])
    async def job_list_text(self, ctx):
        """Show all available jobs"""
        embed = discord.Embed(
            title="ðŸ’¼ Available Jobs",
            description="Here are all the career opportunities:",
            color=0x3498db
        )
        
        for job_id, job_data in self.jobs.items():
            wage_range = f"{job_data['wage']['min']:,} - {job_data['wage']['max']:,} {self.currency}"
            embed.add_field(
                name=f"{job_data['emoji']} {job_data['name']}",
                value=f"{job_data['description']}\n**Wage:** {wage_range}",
                inline=False
            )
        
        embed.set_footer(text="Use .choosejob <job_name> to apply for a job!")
        await ctx.reply(embed=embed)

    @commands.command(name="coworkers", aliases=["colleagues", "teammates"])
    async def coworkers_text(self, ctx):
        """See who else works the same job in this server"""
        user_job = await self.get_user_job(ctx.author.id)
        if not user_job or "name" not in user_job:
            await ctx.reply("You need a job first!")
            return
        
        job_id = user_job.get("job_id", "")
        if not job_id:
            await ctx.reply("Your job data is corrupted!")
            return
        
        # Find all users in the guild with the same job
        guild_members = [member.id for member in ctx.guild.members if not member.bot]
        coworkers = []
        
        for member_id in guild_members:
            if member_id == ctx.author.id:
                continue
            member_job = await self.get_user_job(member_id)
            if member_job and member_job.get("job_id") == job_id:
                member = ctx.guild.get_member(member_id)
                if member:
                    coworkers.append(member.display_name)
        
        job_info = self.jobs.get(job_id, {})
        embed = discord.Embed(
            title=f"{job_info.get('emoji', 'ðŸ’¼')} Coworkers",
            color=0x2ecc71
        )
        
        if coworkers:
            embed.description = f"**{len(coworkers)}** other people work as **{user_job['name']}** in this server:\n\n" + "\n".join([f"â€¢ {name}" for name in coworkers[:20]])
            if len(coworkers) > 20:
                embed.description += f"\n... and {len(coworkers) - 20} more"
            embed.set_footer(text="ðŸ’¡ Ask for a raise at the same time as a coworker for a group bonus!")
        else:
            embed.description = f"You're the only **{user_job['name']}** in this server. How lonely! ðŸ˜¢"
        
        await ctx.reply(embed=embed)

class JobManagementView(discord.ui.View):
    def __init__(self, work_cog, user_job, original_user_id):
        super().__init__(timeout=300)
        self.work_cog = work_cog
        self.user_job = user_job
        self.original_user_id = original_user_id

    @discord.ui.button(label="Choose Job", style=discord.ButtonStyle.primary, emoji="ðŸ“‹")
    async def choose_job(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't use someone else's job interface!", ephemeral=True)
            return
            
        if self.user_job and "name" in self.user_job:
            embed = discord.Embed(
                title="âš ï¸ Already Employed",
                description="You already have a job! Leave your current job first if you want to switch.",
                color=0xf39c12
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return
        
        view = JobSelectionView(self.work_cog, self.original_user_id)
        embed = discord.Embed(
            title="ðŸŽ¯ Choose Your Career Path",
            description="Select a job that matches your skillset:",
            color=0x9b59b6
        )
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

    @discord.ui.button(label="Boss Relations", style=discord.ButtonStyle.secondary, emoji="ðŸ‘”")
    async def boss_relations(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't use someone else's job interface!", ephemeral=True)
            return
            
        if not self.user_job or "name" not in self.user_job:
            await interaction.response.send_message("You need a job first!", ephemeral=True)
            return
            
        view = BossRelationsView(self.work_cog, self.user_job, self.original_user_id)
        embed = discord.Embed(
            title="ðŸ‘” Boss Relations",
            description="Manage your relationship with your boss",
            color=0x34495e
        )
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

    @discord.ui.button(label="Leave Job", style=discord.ButtonStyle.danger, emoji="ðŸšª")
    async def leave_job(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't use someone else's job interface!", ephemeral=True)
            return
            
        if not self.user_job or "name" not in self.user_job:
            await interaction.response.send_message("You don't have a job to leave!", ephemeral=True)
            return
            
        cooldown = time.time() + 6 * 3600
        await self.work_cog.update_user_job(interaction.user.id, {"cooldown": cooldown})
        
        embed = discord.Embed(
            title="ðŸšª Job Left",
            description=f"You have left your job as **{self.user_job['name']}**.\nYou can choose a new job in **6 hours**.",
            color=0xe74c3c
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class JobSelectionView(discord.ui.View):
    def __init__(self, work_cog, original_user_id):
        super().__init__(timeout=300)
        self.work_cog = work_cog
        self.original_user_id = original_user_id
        
        # Create select menu for jobs
        options = []
        for job_id, job_data in work_cog.jobs.items():
            options.append(discord.SelectOption(
                label=job_data["name"],
                description=job_data["description"][:100],
                emoji=job_data["emoji"],
                value=job_id
            ))
        
        select = discord.ui.Select(
            placeholder="Choose your career path...",
            options=options[:25]  # Discord limit
        )
        select.callback = self.job_selected
        self.add_item(select)

    async def job_selected(self, interaction: discord.Interaction):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't select a job for someone else!", ephemeral=True)
            return
            
        job_id = interaction.data["values"][0]
        job_data = self.work_cog.jobs[job_id].copy()
        job_data["job_id"] = job_id
        job_data["free_raise"] = False
        
        await self.work_cog.update_user_job(interaction.user.id, job_data)
        
        embed = discord.Embed(
            title="ðŸŽ‰ Job Acquired!",
            description=f"You are now a **{job_data['name']}**!\n\n{job_data['description']}\n\nWage Range: {job_data['wage']['min']:,} - {job_data['wage']['max']:,} {self.work_cog.currency}",
            color=0x2ecc71
        )
        await interaction.response.send_message(embed=embed, ephemeral=True)

class BossRelationsView(discord.ui.View):
    def __init__(self, work_cog, user_job, original_user_id):
        super().__init__(timeout=300)
        self.work_cog = work_cog
        self.user_job = user_job
        self.original_user_id = original_user_id

    @discord.ui.button(label="Ask for Raise", style=discord.ButtonStyle.success, emoji="ðŸ’°")
    async def ask_raise(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't ask for a raise for someone else!", ephemeral=True)
            return
            
        if self.user_job["boss"]["hostile"] > 50:
            embed = discord.Embed(
                title="ðŸ˜¡ Boss Too Hostile",
                description="Your boss is too angry to consider a raise right now. Try gifting them something first!",
                color=0xe74c3c
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return

        # Check for group raise opportunity
        job_id = self.user_job.get("job_id", "")
        current_time = time.time()
        
        # Clean old requests
        for key in list(self.work_cog.pending_raises.keys()):
            if current_time - self.work_cog.pending_raises[key]["time"] > 2:
                del self.work_cog.pending_raises[key]
        
        # Check if someone else with same job asked recently
        group_raise = False
        for user_id, data in self.work_cog.pending_raises.items():
            if data["job_id"] == job_id and user_id != str(interaction.user.id):
                group_raise = True
                break
        
        # Add current request
        self.work_cog.pending_raises[str(interaction.user.id)] = {
            "job_id": job_id,
            "time": current_time
        }
        
        success_chance = self.user_job["boss"]["loyalty"] + 20
        if group_raise:
            success_chance = 100  # Guaranteed success for group raises
        
        success = random.randint(0, 100) < success_chance
        
        if success:
            if group_raise and not self.user_job.get("free_raise", False):
                # Group raise bonus
                raise_amount = random.randint(200, 800)
                self.user_job["wage"]["max"] += raise_amount
                self.user_job["free_raise"] = True
                await self.work_cog.update_user_job(interaction.user.id, self.user_job)
                
                embed = discord.Embed(
                    title="ðŸŽ‰ GROUP RAISE APPROVED!",
                    description=f"You and your coworkers demanded a raise together!\nYour maximum wage increased by **{raise_amount:,}** {self.work_cog.currency}!",
                    color=0xf1c40f
                )
            else:
                raise_amount = random.randint(100, 500)
                self.user_job["wage"]["max"] += raise_amount
                self.user_job["boss"]["loyalty"] += 5
                await self.work_cog.update_user_job(interaction.user.id, self.user_job)
                
                embed = discord.Embed(
                    title="ðŸ’° Raise Approved!",
                    description=f"Your boss approved your raise!\nMaximum wage increased by **{raise_amount:,}** {self.work_cog.currency}",
                    color=0x2ecc71
                )
        else:
            self.user_job["boss"]["hostile"] += 5
            await self.work_cog.update_user_job(interaction.user.id, self.user_job)
            
            embed = discord.Embed(
                title="âŒ Raise Denied",
                description="Your boss declined your raise request and is now more hostile.",
                color=0xe74c3c
            )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

    @discord.ui.button(label="Gift Boss", style=discord.ButtonStyle.secondary, emoji="ðŸŽ")
    async def gift_boss(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't gift someone else's boss!", ephemeral=True)
            return
            
        # Load items from shop
        try:
            with open('/home/ks/Desktop/bot/data/shop/items.json', 'r') as f:
                shop_items = json.load(f)
        except:
            shop_items = {}
        
        inventory = await self.work_cog.db.get_inventory(interaction.user.id)
        giftable_items = []
        
        # Check inventory for giftable items
        for item in inventory:
            if not isinstance(item, dict):
                continue
            item_id = item.get("id", item.get("name", "").lower().replace(" ", "_"))
            if item_id in shop_items:
                giftable_items.append(item)
        
        if not giftable_items:
            embed = discord.Embed(
                title="ðŸŽ No Gifts Available",
                description="You don't have any items to gift your boss. Buy something from the shop first!",
                color=0xf39c12
            )
            await interaction.response.send_message(embed=embed, ephemeral=True)
            return
        
        # Create selection for gifting
        options = []
        for item in giftable_items[:25]:
            options.append(discord.SelectOption(
                label=item.get("name", "Unknown Item"),
                description=f"Value: {item.get('price', 0):,}",
                value=item.get("id", item.get("name", ""))
            ))
        
        view = GiftSelectionView(self.work_cog, self.user_job, giftable_items, self.original_user_id)
        embed = discord.Embed(
            title="ðŸŽ Choose a Gift",
            description="Select an item to gift your boss:",
            color=0x9b59b6
        )
        await interaction.response.send_message(embed=embed, view=view, ephemeral=True)

class GiftSelectionView(discord.ui.View):
    def __init__(self, work_cog, user_job, items, original_user_id):
        super().__init__(timeout=300)
        self.work_cog = work_cog
        self.user_job = user_job
        self.items = items
        self.original_user_id = original_user_id
        
        options = []
        for item in items[:25]:
            options.append(discord.SelectOption(
                label=item.get("name", "Unknown Item"),
                description=f"Value: {item.get('price', 0):,}",
                value=item.get("id", item.get("name", ""))
            ))
        
        select = discord.ui.Select(placeholder="Choose item to gift...", options=options)
        select.callback = self.item_selected
        self.add_item(select)

    async def item_selected(self, interaction: discord.Interaction):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't gift items for someone else!", ephemeral=True)
            return
            
        item_id = interaction.data["values"][0]
        
        # Remove item from inventory
        success = await db.remove_from_inventory(interaction.user.id, interaction.guild_id, item_id, 1)
        
        if success:
            # Calculate hostility reduction based on item value
            item = next((i for i in self.items if i.get("id") == item_id), None)
            item_value = item.get("price", 100) if item else 100
            
            hostility_reduction = min(30, max(5, item_value // 1000))
            loyalty_increase = min(15, max(2, item_value // 2000))
            
            self.user_job["boss"]["hostile"] = max(0, self.user_job["boss"]["hostile"] - hostility_reduction)
            self.user_job["boss"]["loyalty"] = min(100, self.user_job["boss"]["loyalty"] + loyalty_increase)
            
            await self.work_cog.update_user_job(interaction.user.id, self.user_job)
            
            embed = discord.Embed(
                title="ðŸŽ Gift Delivered!",
                description=f"You gifted **{item.get('name', 'Unknown Item')}** to your boss!\n\nHostility: -{hostility_reduction}\nLoyalty: +{loyalty_increase}",
                color=0x2ecc71
            )
        else:
            embed = discord.Embed(
                title="âŒ Gift Failed",
                description="Failed to remove the item from your inventory.",
                color=0xe74c3c
            )
        
        await interaction.response.send_message(embed=embed, ephemeral=True)

# Minigame classes
class ModerationMinigame(discord.ui.View):
    def __init__(self, work_cog, user_job, original_user_id):
        super().__init__(timeout=60)
        self.work_cog = work_cog
        self.user_job = user_job
        self.original_user_id = original_user_id
        self.used = False  # Track if any button has been used

    @discord.ui.button(label="Ban Spam Bot", style=discord.ButtonStyle.danger, emoji="ðŸ”¨")
    async def ban_bot(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "banned a spam bot", 1.2)

    @discord.ui.button(label="Delete NSFW", style=discord.ButtonStyle.secondary, emoji="ðŸ—‘ï¸")
    async def delete_nsfw(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "deleted inappropriate content", 1.0)

    @discord.ui.button(label="Ignore Report", style=discord.ButtonStyle.success, emoji="ðŸ˜´")
    async def ignore_report(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "ignored a user report", 0.8)

    async def complete_work(self, interaction, action, multiplier):
        # Set cooldown
        await self.work_cog.set_work_cooldown(interaction.user.id)
        
        base_wage = random.randint(self.user_job["wage"]["min"], self.user_job["wage"]["max"])
        final_wage = int(base_wage * multiplier)
        
        await db.update_wallet(interaction.user.id, final_wage, interaction.guild_id)
        
        # Disable all buttons
        for item in self.children:
            item.disabled = True
        
        embed = discord.Embed(
            title="ðŸ”¨ Moderation Complete",
            description=f"You {action} and earned **{final_wage:,}** {self.work_cog.currency}!",
            color=0x2ecc71
        )
        embed.add_field(name="ðŸ’° Earnings", value=f"+{final_wage:,} {self.work_cog.currency}", inline=True)
        await interaction.response.edit_message(embed=embed, view=self)

class CryptoMinigame(discord.ui.View):
    def __init__(self, work_cog, user_job, original_user_id):
        super().__init__(timeout=60)
        self.work_cog = work_cog
        self.user_job = user_job
        self.original_user_id = original_user_id
        self.used = False

    @discord.ui.button(label="HODL ðŸ’ŽðŸ™Œ", style=discord.ButtonStyle.primary, emoji="ðŸ’Ž")
    async def hodl(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        success = random.choice([True, False])
        multiplier = 2.0 if success else 0.1
        action = "diamond handed to the moon" if success else "paper handed like a noob"
        await self.complete_work(interaction, action, multiplier)

    @discord.ui.button(label="Buy the Dip", style=discord.ButtonStyle.success, emoji="ðŸ“‰")
    async def buy_dip(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "bought the dip", 1.3)

    @discord.ui.button(label="Panic Sell", style=discord.ButtonStyle.danger, emoji="ðŸ“ˆ")
    async def panic_sell(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "panic sold at a loss", 0.5)

    async def complete_work(self, interaction, action, multiplier):
        # Set cooldown
        await self.work_cog.set_work_cooldown(interaction.user.id)
        
        base_wage = random.randint(self.user_job["wage"]["min"], self.user_job["wage"]["max"])
        final_wage = int(base_wage * multiplier)
        
        await db.update_wallet(interaction.user.id, final_wage, interaction.guild_id)
        
        # Disable all buttons
        for item in self.children:
            item.disabled = True
        
        embed = discord.Embed(
            title="ðŸ“ˆ Crypto Trading Complete",
            description=f"You {action} and earned **{final_wage:,}** {self.work_cog.currency}!",
            color=0xf39c12
        )
        embed.add_field(name="ðŸ’° Earnings", value=f"+{final_wage:,} {self.work_cog.currency}", inline=True)
        await interaction.response.edit_message(embed=embed, view=self)

class RedditMinigame(discord.ui.View):
    def __init__(self, work_cog, user_job, original_user_id):
        super().__init__(timeout=60)
        self.work_cog = work_cog
        self.user_job = user_job
        self.original_user_id = original_user_id
        self.used = False

    @discord.ui.button(label="Lock Thread", style=discord.ButtonStyle.danger, emoji="ðŸ”’")
    async def lock_thread(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "locked a controversial thread", 1.1)

    @discord.ui.button(label="Award Gold", style=discord.ButtonStyle.secondary, emoji="ðŸ†")
    async def award_gold(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "gave yourself Reddit Gold", 0.9)

    @discord.ui.button(label="Ban User", style=discord.ButtonStyle.success, emoji="ðŸ”¨")
    async def ban_user(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "banned someone for wrongthink", 1.3)

    @discord.ui.button(label="Edit Comment", style=discord.ButtonStyle.primary, emoji="âœï¸")
    async def edit_comment(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "secretly edited someone's comment", 1.5)

    async def complete_work(self, interaction, action, multiplier):
        # Set cooldown
        await self.work_cog.set_work_cooldown(interaction.user.id)
        
        base_wage = random.randint(self.user_job["wage"]["min"], self.user_job["wage"]["max"])
        final_wage = int(base_wage * multiplier)
        
        await db.update_wallet(interaction.user.id, final_wage, interaction.guild_id)
        
        # Disable all buttons
        for item in self.children:
            item.disabled = True
        
        embed = discord.Embed(
            title="ðŸ¤“ Reddit Admin Work Complete",
            description=f"You {action} and earned **{final_wage:,}** {self.work_cog.currency}!",
            color=0xff4500
        )
        embed.add_field(name="ðŸ’° Earnings", value=f"+{final_wage:,} {self.work_cog.currency}", inline=True)
        await interaction.response.edit_message(embed=embed, view=self)

class SimpMinigame(discord.ui.View):
    def __init__(self, work_cog, user_job, original_user_id):
        super().__init__(timeout=60)
        self.work_cog = work_cog
        self.user_job = user_job
        self.original_user_id = original_user_id
        self.used = False

    @discord.ui.button(label="Donate $1000", style=discord.ButtonStyle.danger, emoji="ðŸ’¸")
    async def big_donation(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        success = random.randint(1, 10) == 1  # 10% chance
        if success:
            await self.complete_work(interaction, "got noticed! Poki said your name!", 2.5)
        else:
            await self.complete_work(interaction, "donated but got ignored... again", 0.3)

    @discord.ui.button(label="Spam Chat", style=discord.ButtonStyle.secondary, emoji="ðŸ’¬")
    async def spam_chat(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "spammed 'QUEEN' 100 times in chat", 0.8)

    @discord.ui.button(label="Buy Merchandise", style=discord.ButtonStyle.success, emoji="ðŸ‘•")
    async def buy_merch(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "bought overpriced merch you'll never wear", 1.0)

    @discord.ui.button(label="Defend Honor", style=discord.ButtonStyle.primary, emoji="âš”ï¸")
    async def defend_honor(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "fought the haters in Twitter replies", 1.2)

    async def complete_work(self, interaction, action, multiplier):
        # Set cooldown
        await self.work_cog.set_work_cooldown(interaction.user.id)
        
        base_wage = random.randint(self.user_job["wage"]["min"], self.user_job["wage"]["max"])
        final_wage = int(base_wage * multiplier)
        
        await db.update_wallet(interaction.user.id, final_wage, interaction.guild_id)
        
        # Disable all buttons
        for item in self.children:
            item.disabled = True
        
        embed = discord.Embed(
            title="ðŸ’¸ Simp Work Complete",
            description=f"You {action} and earned **{final_wage:,}** {self.work_cog.currency}!",
            color=0xff69b4
        )
        embed.add_field(name="ðŸ’° Earnings", value=f"+{final_wage:,} {self.work_cog.currency}", inline=True)
        await interaction.response.edit_message(embed=embed, view=self)

class MemeMinigame(discord.ui.View):
    def __init__(self, work_cog, user_job, original_user_id):
        super().__init__(timeout=60)
        self.work_cog = work_cog
        self.user_job = user_job
        self.original_user_id = original_user_id
        self.used = False

    @discord.ui.button(label="Post Drake Meme", style=discord.ButtonStyle.danger, emoji="ðŸŽ¤")
    async def drake_meme(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "posted a Drake pointing meme", 0.7)

    @discord.ui.button(label="Create OC", style=discord.ButtonStyle.secondary, emoji="ðŸŽ¨")
    async def create_oc(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        viral = random.randint(1, 20) == 1  # 5% chance to go viral
        if viral:
            await self.complete_work(interaction, "created OC that went viral! ðŸ”¥", 3.0)
        else:
            await self.complete_work(interaction, "created OC that got 3 upvotes", 1.2)

    @discord.ui.button(label="Repost Classic", style=discord.ButtonStyle.success, emoji="â™»ï¸")
    async def repost_classic(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "reposted a 2012 meme for easy karma", 0.9)

    @discord.ui.button(label="Deep Fry Meme", style=discord.ButtonStyle.primary, emoji="ðŸŸ")
    async def deep_fry(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "deep fried a meme until it was unrecognizable", 1.4)

    async def complete_work(self, interaction, action, multiplier):
        # Set cooldown
        await self.work_cog.set_work_cooldown(interaction.user.id)
        
        base_wage = random.randint(self.user_job["wage"]["min"], self.user_job["wage"]["max"])
        final_wage = int(base_wage * multiplier)
        
        await db.update_wallet(interaction.user.id, final_wage, interaction.guild_id)
        
        # Disable all buttons
        for item in self.children:
            item.disabled = True
        
        embed = discord.Embed(
            title="ðŸ—¿ Meme Work Complete",
            description=f"You {action} and earned **{final_wage:,}** {self.work_cog.currency}!",
            color=0x00ff00
        )
        embed.add_field(name="ðŸ’° Earnings", value=f"+{final_wage:,} {self.work_cog.currency}", inline=True)
        await interaction.response.edit_message(embed=embed, view=self)

class NFTMinigame(discord.ui.View):
    def __init__(self, work_cog, user_job, original_user_id):
        super().__init__(timeout=60)
        self.work_cog = work_cog
        self.user_job = user_job
        self.original_user_id = original_user_id
        self.used = False

    @discord.ui.button(label="Right-Click Save", style=discord.ButtonStyle.danger, emoji="ðŸ–±ï¸")
    async def right_click(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        caught = random.randint(1, 5) == 1  # 20% chance to get caught
        if caught:
            await self.complete_work(interaction, "got sued for right-clicking", 0.0)
        else:
            await self.complete_work(interaction, "successfully pirated 100 NFTs", 1.8)

    @discord.ui.button(label="Mint Apes", style=discord.ButtonStyle.secondary, emoji="ðŸµ")
    async def mint_apes(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "minted 10,000 procedurally generated apes", 2.2)

    @discord.ui.button(label="Pump & Dump", style=discord.ButtonStyle.success, emoji="ðŸ“ˆ")
    async def pump_dump(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        success = random.choice([True, False])
        if success:
            await self.complete_work(interaction, "successfully pumped and dumped", 4.0)
        else:
            await self.complete_work(interaction, "got rekt by your own pump and dump", 0.1)

    @discord.ui.button(label="Wash Trade", style=discord.ButtonStyle.primary, emoji="ðŸ§½")
    async def wash_trade(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "wash traded with your alt accounts", 1.5)

    async def complete_work(self, interaction, action, multiplier):
        # Set cooldown
        await self.work_cog.set_work_cooldown(interaction.user.id)
        
        base_wage = random.randint(self.user_job["wage"]["min"], self.user_job["wage"]["max"])
        final_wage = int(base_wage * multiplier)
        
        await db.update_wallet(interaction.user.id, final_wage, interaction.guild_id)
        
        # Disable all buttons
        for item in self.children:
            item.disabled = True
        
        embed = discord.Embed(
            title="ðŸ–¼ï¸ NFT Trading Complete",
            description=f"You {action} and earned **{final_wage:,}** {self.work_cog.currency}!",
            color=0x9932cc
        )
        embed.add_field(name="ðŸ’° Earnings", value=f"+{final_wage:,} {self.work_cog.currency}", inline=True)
        await interaction.response.edit_message(embed=embed, view=self)

class TwitterMinigame(discord.ui.View):
    def __init__(self, work_cog, user_job, original_user_id):
        super().__init__(timeout=60)
        self.work_cog = work_cog
        self.user_job = user_job
        self.original_user_id = original_user_id
        self.used = False

    @discord.ui.button(label="Quote Tweet Drama", style=discord.ButtonStyle.danger, emoji="ðŸ”¥")
    async def quote_tweet(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        backfire = random.randint(1, 3) == 1  # 33% chance to backfire
        if backfire:
            await self.complete_work(interaction, "got ratio'd for your bad take", 0.2)
        else:
            await self.complete_work(interaction, "started a Twitter mob successfully", 1.3)

    @discord.ui.button(label="Cancel Someone", style=discord.ButtonStyle.secondary, emoji="âŒ")
    async def cancel_someone(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "got someone fired over a 2009 tweet", 1.1)

    @discord.ui.button(label="Thread Rant", style=discord.ButtonStyle.success, emoji="ðŸ§µ")
    async def thread_rant(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "wrote a 47-tweet thread about cereal", 0.8)

    @discord.ui.button(label="Virtue Signal", style=discord.ButtonStyle.primary, emoji="ðŸ˜‡")
    async def virtue_signal(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "posted about current thing for clout", 0.9)

    async def complete_work(self, interaction, action, multiplier):
        # Set cooldown
        await self.work_cog.set_work_cooldown(interaction.user.id)
        
        base_wage = random.randint(self.user_job["wage"]["min"], self.user_job["wage"]["max"])
        final_wage = int(base_wage * multiplier)
        
        await db.update_wallet(interaction.user.id, final_wage, interaction.guild_id)
        
        # Disable all buttons
        for item in self.children:
            item.disabled = True
        
        embed = discord.Embed(
            title="ðŸ¦ Twitter Warrior Work Complete",
            description=f"You {action} and earned **{final_wage:,}** {self.work_cog.currency}!",
            color=0x1da1f2
        )
        embed.add_field(name="ðŸ’° Earnings", value=f"+{final_wage:,} {self.work_cog.currency}", inline=True)
        await interaction.response.edit_message(embed=embed, view=self)

class StreamingMinigame(discord.ui.View):
    def __init__(self, work_cog, user_job, original_user_id):
        super().__init__(timeout=60)
        self.work_cog = work_cog
        self.user_job = user_job
        self.original_user_id = original_user_id
        self.used = False

    @discord.ui.button(label="Play Just Chatting", style=discord.ButtonStyle.danger, emoji="ðŸ’¬")
    async def just_chatting(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "sat in front of camera doing nothing", 0.6)

    @discord.ui.button(label="React to Videos", style=discord.ButtonStyle.secondary, emoji="ðŸ“º")
    async def react_content(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        dmca = random.randint(1, 10) == 1  # 10% chance
        if dmca:
            await self.complete_work(interaction, "got DMCA'd mid-stream", 0.1)
        else:
            await self.complete_work(interaction, "stole content legally by adding 'commentary'", 1.4)

    @discord.ui.button(label="Beg for Subs", style=discord.ButtonStyle.success, emoji="ðŸ™")
    async def beg_subs(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        await self.complete_work(interaction, "guilt-tripped viewers into subscribing", 1.1)

    @discord.ui.button(label="Accidental Stream", style=discord.ButtonStyle.primary, emoji="ðŸ˜±")
    async def accidental_stream(self, interaction: discord.Interaction, button: discord.ui.Button):
        if interaction.user.id != self.original_user_id:
            await interaction.response.send_message("You can't work someone else's job!", ephemeral=True)
            return
        if self.used:
            await interaction.response.send_message("You already completed this work session!", ephemeral=True)
            return
        self.used = True
        viral = random.randint(1, 50) == 1  # 2% chance to go viral
        if viral:
            await self.complete_work(interaction, "accidentally went viral on LSF", 5.0)
        else:
            await self.complete_work(interaction, "leaked your DMs on accident", 0.3)

    async def complete_work(self, interaction, action, multiplier):
        # Set cooldown
        await self.work_cog.set_work_cooldown(interaction.user.id)
        
        base_wage = random.randint(self.user_job["wage"]["min"], self.user_job["wage"]["max"])
        final_wage = int(base_wage * multiplier)
        
        await db.update_wallet(interaction.user.id, final_wage, interaction.guild_id)
        
        # Disable all buttons
        for item in self.children:
            item.disabled = True
        
        embed = discord.Embed(
            title="ðŸŽ® Streaming Work Complete",
            description=f"You {action} and earned **{final_wage:,}** {self.work_cog.currency}!",
            color=0x9146ff
        )
        embed.add_field(name="ðŸ’° Earnings", value=f"+{final_wage:,} {self.work_cog.currency}", inline=True)
        await interaction.response.edit_message(embed=embed, view=self)

class DefaultMinigame(discord.ui.View):
    def __init__(self, work_cog, user_job, original_user_id):
        super().__init__(timeout=180)  # Longer timeout for minesweeper
        self.work_cog = work_cog
        self.user_job = user_job
        self.original_user_id = original_user_id
        self.board_size = 5
        self.mine_count = 5
        self.board = self.generate_board()
        self.revealed = [[False for _ in range(self.board_size)] for _ in range(self.board_size)]
        self.flagged = [[False for _ in range(self.board_size)] for _ in range(self.board_size)]
        self.game_over = False
        self.won = False
        self.first_click = True
        self.work_completed = False  # Track if work has been completed
        
        # Add buttons for the minesweeper grid
        for row in range(self.board_size):
            for col in range(self.board_size):
                button = MinesweeperButton(row, col, self)
                self.add_item(button)
        
        # Add control buttons
        self.add_item(FlagModeButton(self))
        self.add_item(RestartButton(self))

    def generate_board(self):
        """Generate a minesweeper board with mines and numbers"""
        board = [[0 for _ in range(self.board_size)] for _ in range(self.board_size)]
        
        # Place mines randomly
        mines_placed = 0
        while mines_placed < self.mine_count:
            row = random.randint(0, self.board_size - 1)
            col = random.randint(0, self.board_size - 1)
            if board[row][col] != -1:  # -1 represents a mine
                board[row][col] = -1
                mines_placed += 1
        
        # Calculate numbers for each cell
        for row in range(self.board_size):
            for col in range(self.board_size):
                if board[row][col] != -1:
                    count = 0
                    for dr in [-1, 0, 1]:
                        for dc in [-1, 0, 1]:
                            if dr == 0 and dc == 0:
                                continue
                            new_row, new_col = row + dr, col + dc
                            if (0 <= new_row < self.board_size and 
                                0 <= new_col < self.board_size and 
                                board[new_row][new_col] == -1):
                                count += 1
                    board[row][col] = count
        
        return board

    def get_cell_emoji(self, row, col):
        """Get the emoji for a cell based on its state"""
        if self.flagged[row][col]:
            return "ðŸš©"
        if not self.revealed[row][col]:
            return "â¬œ"
        
        if self.board[row][col] == -1:
            return "ðŸ’¥"
        elif self.board[row][col] == 0:
            return "â¬›"
        else:
            number_emojis = ["0ï¸âƒ£", "1ï¸âƒ£", "2ï¸âƒ£", "3ï¸âƒ£", "4ï¸âƒ£", "5ï¸âƒ£", "6ï¸âƒ£", "7ï¸âƒ£", "8ï¸âƒ£"]
            return number_emojis[self.board[row][col]]

    def reveal_cell(self, row, col):
        """Reveal a cell and cascade if it's empty"""
        if (row < 0 or row >= self.board_size or 
            col < 0 or col >= self.board_size or 
            self.revealed[row][col] or 
            self.flagged[row][col]):
            return
        
        self.revealed[row][col] = True
        
        # If it's a mine, game over
        if self.board[row][col] == -1:
            self.game_over = True
            self.won = False
            return
        
        # If it's empty, reveal adjacent cells
        if self.board[row][col] == 0:
            for dr in [-1, 0, 1]:
                for dc in [-1, 0, 1]:
                    if dr == 0 and dc == 0:
                        continue
                    self.reveal_cell(row + dr, col + dc)

    def check_win(self):
        """Check if the player has won"""
        for row in range(self.board_size):
            for col in range(self.board_size):
                if self.board[row][col] != -1 and not self.revealed[row][col]:
                    return False
        return True

    def get_board_display(self):
        """Get the visual representation of the board"""
        board_str = ""
        for row in range(self.board_size):
            for col in range(self.board_size):
                board_str += self.get_cell_emoji(row, col)
            board_str += "\n"
        return board_str

    async def complete_work(self, interaction, won):
        """Complete the work and calculate wages based on performance"""
        if self.work_completed:
            return  # Prevent multiple completions
        
        self.work_completed = True
        
        # Set cooldown
        await self.work_cog.set_work_cooldown(interaction.user.id)
        
        base_wage = random.randint(self.user_job["wage"]["min"], self.user_job["wage"]["max"])
        
        if won:
            multiplier = 1.5  # Bonus for winning
            action = "completed the minesweeper perfectly"
        else:
            multiplier = 0.7  # Reduced wage for losing
            action = "hit a mine and failed the task"
        
        final_wage = int(base_wage * multiplier)
        
        await db.update_wallet(interaction.user.id, final_wage, interaction.guild_id)
        
        embed = discord.Embed(
            title="ðŸ’¼ Default Work Complete",
            description=f"You {action} and earned **{final_wage:,}** {self.work_cog.currency}!",
            color=0x2ecc71 if won else 0xe74c3c
        )
        
        if won:
            embed.add_field(name="ðŸŽ‰ Success!", value="Perfect job performance!", inline=False)
        else:
            embed.add_field(name="ðŸ’¥ Failure", value="Better luck next time!", inline=False)
        
        await interaction.followup.send(embed=embed)

class MinesweeperButton(discord.ui.Button):
    def __init__(self, row, col, game):
        self.row = row
        self.col = col
        self.game = game
        super().__init__(
            emoji=game.get_cell_emoji(row, col),
            style=discord.ButtonStyle.secondary,
            row=row
       
        )

    async def callback(self, interaction):
        if interaction.user.id != self.game.original_user_id:
            await interaction.response.send_message("You can't interact with someone else's game!", ephemeral=True)
            return
            
        if self.game.game_over:
            await interaction.response.send_message("Game is already over!", ephemeral=True)
            return
        
        # Check if in flag mode
        flag_mode = False
        for item in self.game.children:
            if isinstance(item, FlagModeButton):
                flag_mode = item.flag_mode
                break
        
        if flag_mode:
            # Toggle flag
            if not self.game.revealed[self.row][self.col]:
                self.game.flagged[self.row][self.col] = not self.game.flagged[self.row][self.col]
        else:
            # Reveal cell
            if not self.game.flagged[self.row][self.col]:
                self.game.reveal_cell(self.row, self.col)
        
        # Update button emojis
        for item in self.game.children:
            if isinstance(item, MinesweeperButton):
                item.emoji = self.game.get_cell_emoji(item.row, item.col)
        
        # Check game state
        if self.game.game_over:
            if self.game.won:
                embed_title = "ðŸŽ‰ Minesweeper - You Won!"
                embed_color = 0x2ecc71
            else:
                embed_title = "ðŸ’¥ Minesweeper - Game Over!"
                embed_color = 0xe74c3c
                # Reveal all mines
                for row in range(self.game.board_size):
                    for col in range(self.game.board_size):
                        if self.game.board[row][col] == -1:
                            self.game.revealed[row][col] = True
                
                # Update button emojis again to show mines
                for item in self.game.children:
                    if isinstance(item, MinesweeperButton):
                        item.emoji = self.game.get_cell_emoji(item.row, item.col)
            
            # Disable all buttons
            for item in self.game.children:
                item.disabled = True
            
            embed = discord.Embed(
                title=embed_title,
                description=f"```\n{self.game.get_board_display()}\n```",
                color=embed_color
            )
            
            await interaction.response.edit_message(embed=embed, view=self.game)
            await self.game.complete_work(interaction, self.game.won)
        elif self.game.check_win():
            self.game.game_over = True
            self.game.won = True
            
            # Disable all buttons
            for item in self.game.children:
                item.disabled = True
            
            embed = discord.Embed(
                title="ðŸŽ‰ Minesweeper - You Won!",
                description=f"```\n{self.game.get_board_display()}\n```",
                color=0x2ecc71
            )
            
            await interaction.response.edit_message(embed=embed, view=self.game)
            await self.game.complete_work(interaction, True)
        else:
            embed = discord.Embed(
                title="ðŸ’£ Minesweeper - Clear the field!",
                description=f"```\n{self.game.get_board_display()}\n```\nClick cells to reveal them. Use flag mode to mark mines!",
                color=0x3498db
            )
            
            await interaction.response.edit_message(embed=embed, view=self.game)

class FlagModeButton(discord.ui.Button):
    def __init__(self, game):
        self.game = game
        self.flag_mode = False
        super().__init__(
            label="Flag Mode: OFF",
            style=discord.ButtonStyle.primary,
            emoji="ðŸš©",
            row=4
        )

    async def callback(self, interaction):
        if interaction.user.id != self.game.original_user_id:
            await interaction.response.send_message("You can't interact with someone else's game!", ephemeral=True)
            return
            
        if self.game.game_over:
            await interaction.response.send_message("Game is already over!", ephemeral=True)
            return
        
        self.flag_mode = not self.flag_mode
        self.label = f"Flag Mode: {'ON' if self.flag_mode else 'OFF'}"
        self.style = discord.ButtonStyle.success if self.flag_mode else discord.ButtonStyle.primary
        
        embed = discord.Embed(
            title="ðŸ’£ Minesweeper - Clear the field!",
            description=f"```\n{self.game.get_board_display()}\n```\nFlag mode: {'ON' if self.flag_mode else 'OFF'} - Click cells to {'flag' if self.flag_mode else 'reveal'} them!",
            color=0x3498db
        )
        
        await interaction.response.edit_message(embed=embed, view=self.game)

class RestartButton(discord.ui.Button):
    def __init__(self, game):
        self.game = game
        super().__init__(
            label="New Game",
            style=discord.ButtonStyle.danger,
            emoji="ðŸ”„",
            row=4
        )

    async def callback(self, interaction):
        if interaction.user.id != self.game.original_user_id:
            await interaction.response.send_message("You can't interact with someone else's game!", ephemeral=True)
            return
            
        # Reset the game
        self.game.board = self.game.generate_board()
        self.game.revealed = [[False for _ in range(self.game.board_size)] for _ in range(self.game.board_size)]
        self.game.flagged = [[False for _ in range(self.game.board_size)] for _ in range(self.game.board_size)]
        self.game.game_over = False
        self.game.won = False
        
        # Reset flag mode
        for item in self.game.children:
            if isinstance(item, FlagModeButton):
                item.flag_mode = False
                item.label = "Flag Mode: OFF"
                item.style = discord.ButtonStyle.primary
                break
        
        # Re-enable and update all buttons
        for item in self.game.children:
            item.disabled = False
            if isinstance(item, MinesweeperButton):
                item.emoji = self.game.get_cell_emoji(item.row, item.col)
        
        embed = discord.Embed(
            title="ðŸ’£ Minesweeper - Clear the field!",
            description=f"```\n{self.game.get_board_display()}\n```\nClick cells to reveal them. Use flag mode to mark mines!",
            color=0x3498db
        )
        
        await interaction.response.edit_message(embed=embed, view=self.game)

async def setup(bot):
    await bot.add_cog(Work(bot))
